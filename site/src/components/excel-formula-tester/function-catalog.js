export const FN_CATALOG = {
  // ── Maths ──
  SOMME:              { min: 1, max: 255, args: "n*",     syntax: "SOMME(nombre1; [nombre2]; ...)",             desc: "Additionne des valeurs" },
  SUM:                { min: 1, max: 255, args: "n*",     syntax: "SUM(number1, [number2], ...)",               desc: "Adds values" },
  MOYENNE:            { min: 1, max: 255, args: "n*",     syntax: "MOYENNE(nombre1; [nombre2]; ...)",           desc: "Calcule la moyenne" },
  AVERAGE:            { min: 1, max: 255, args: "n*",     syntax: "AVERAGE(number1, [number2], ...)",           desc: "Calculates the average" },
  MAX:                { min: 1, max: 255, args: "n*",     syntax: "MAX(nombre1; [nombre2]; ...)",               desc: "Retourne la valeur maximale" },
  MIN:                { min: 1, max: 255, args: "n*",     syntax: "MIN(nombre1; [nombre2]; ...)",               desc: "Retourne la valeur minimale" },
  ARRONDI:            { min: 2, max: 2,   args: "nn",     syntax: "ARRONDI(nombre; nb_chiffres)",               desc: "Arrondit un nombre" },
  ROUND:              { min: 2, max: 2,   args: "nn",     syntax: "ROUND(number, num_digits)",                  desc: "Rounds a number" },
  TRONQUE:            { min: 1, max: 2,   args: "nn",     syntax: "TRONQUE(nombre; [nb_chiffres])",             desc: "Tronque un nombre" },
  TRUNC:              { min: 1, max: 2,   args: "nn",     syntax: "TRUNC(number, [num_digits])",                desc: "Truncates a number" },
  ENT:                { min: 1, max: 1,   args: "n",      syntax: "ENT(nombre)",                                desc: "Partie entière" },
  INT:                { min: 1, max: 1,   args: "n",      syntax: "INT(number)",                                desc: "Integer part" },
  MOD:                { min: 2, max: 2,   args: "nn",     syntax: "MOD(nombre; diviseur)",                      desc: "Reste de la division" },
  ABS:                { min: 1, max: 1,   args: "n",      syntax: "ABS(nombre)",                                desc: "Valeur absolue" },
  RACINE:             { min: 1, max: 1,   args: "n",      syntax: "RACINE(nombre)",                             desc: "Racine carrée" },
  SQRT:               { min: 1, max: 1,   args: "n",      syntax: "SQRT(number)",                               desc: "Square root" },
  PUISSANCE:          { min: 2, max: 2,   args: "nn",     syntax: "PUISSANCE(nombre; puissance)",               desc: "Élève à la puissance" },
  POWER:              { min: 2, max: 2,   args: "nn",     syntax: "POWER(number, power)",                       desc: "Raises to a power" },
  ALEA:               { min: 0, max: 0,   args: "",       syntax: "ALEA()",                                     desc: "Nombre aléatoire entre 0 et 1" },
  RAND:               { min: 0, max: 0,   args: "",       syntax: "RAND()",                                     desc: "Random number 0-1" },
  "ALEA.ENTRE.BORNES":{ min: 2, max: 2,  args: "nn",     syntax: "ALEA.ENTRE.BORNES(min; max)",                desc: "Entier aléatoire entre bornes" },
  RANDBETWEEN:        { min: 2, max: 2,   args: "nn",     syntax: "RANDBETWEEN(bottom, top)",                   desc: "Random integer between bounds" },

  // ── Logique ──
  SI:                 { min: 3, max: 3,   args: "baa",    syntax: "SI(test_logique; valeur_si_vrai; valeur_si_faux)", desc: "Condition si/alors/sinon" },
  IF:                 { min: 3, max: 3,   args: "baa",    syntax: "IF(logical_test, value_if_true, value_if_false)",  desc: "If/then/else condition" },
  ET:                 { min: 1, max: 255, args: "b*",     syntax: "ET(logique1; [logique2]; ...)",              desc: "VRAI si toutes les conditions sont vraies" },
  AND:                { min: 1, max: 255, args: "b*",     syntax: "AND(logical1, [logical2], ...)",             desc: "TRUE if all conditions are true" },
  OU:                 { min: 1, max: 255, args: "b*",     syntax: "OU(logique1; [logique2]; ...)",              desc: "VRAI si au moins une condition est vraie" },
  OR:                 { min: 1, max: 255, args: "b*",     syntax: "OR(logical1, [logical2], ...)",              desc: "TRUE if any condition is true" },
  NON:                { min: 1, max: 1,   args: "b",      syntax: "NON(valeur_logique)",                        desc: "Inverse une valeur logique" },
  NOT:                { min: 1, max: 1,   args: "b",      syntax: "NOT(logical)",                               desc: "Inverts a logical value" },
  SIERREUR:           { min: 2, max: 2,   args: "aa",     syntax: "SIERREUR(valeur; valeur_si_erreur)",         desc: "Retourne une valeur si erreur" },
  IFERROR:            { min: 2, max: 2,   args: "aa",     syntax: "IFERROR(value, value_if_error)",             desc: "Returns value if error" },
  IFS:                { min: 2, max: 254, args: "ba*",    syntax: "IFS(test1; valeur1; [test2; valeur2]; ...)", desc: "Conditions multiples" },
  SWITCH:             { min: 3, max: 254, args: "aaa*",   syntax: "SWITCH(expression; val1; res1; ...)",        desc: "Compare une expression à des valeurs" },

  // ── Comptage ──
  NB:                 { min: 1, max: 255, args: "a*",     syntax: "NB(valeur1; [valeur2]; ...)",                desc: "Compte les cellules numériques" },
  COUNT:              { min: 1, max: 255, args: "a*",     syntax: "COUNT(value1, [value2], ...)",               desc: "Counts numeric cells" },
  NBVAL:              { min: 1, max: 255, args: "a*",     syntax: "NBVAL(valeur1; [valeur2]; ...)",             desc: "Compte les cellules non vides" },
  COUNTA:             { min: 1, max: 255, args: "a*",     syntax: "COUNTA(value1, [value2], ...)",              desc: "Counts non-empty cells" },
  "NB.VIDE":          { min: 1, max: 1,   args: "r",      syntax: "NB.VIDE(plage)",                             desc: "Compte les cellules vides" },
  COUNTBLANK:         { min: 1, max: 1,   args: "r",      syntax: "COUNTBLANK(range)",                          desc: "Counts blank cells" },
  "NB.SI":            { min: 2, max: 2,   args: "rs",     syntax: "NB.SI(plage; critère)",                      desc: "Compte selon un critère" },
  COUNTIF:            { min: 2, max: 2,   args: "rs",     syntax: "COUNTIF(range, criteria)",                   desc: "Counts by criteria" },
  "NB.SI.ENS":        { min: 2, max: 254, args: "rs*",    syntax: "NB.SI.ENS(plage1; critère1; ...)",           desc: "Compte selon plusieurs critères" },
  COUNTIFS:           { min: 2, max: 254, args: "rs*",    syntax: "COUNTIFS(range1, criteria1, ...)",            desc: "Counts by multiple criteria" },

  // ── Somme conditionnelle ──
  "SOMME.SI":         { min: 2, max: 3,   args: "rsr",    syntax: "SOMME.SI(plage; critère; [somme_plage])",    desc: "Somme conditionnelle" },
  SUMIF:              { min: 2, max: 3,   args: "rsr",    syntax: "SUMIF(range, criteria, [sum_range])",        desc: "Conditional sum" },
  "SOMME.SI.ENS":     { min: 3, max: 254, args: "rrs*",   syntax: "SOMME.SI.ENS(somme_plage; plage1; critère1; ...)", desc: "Somme multi-critères" },
  SUMIFS:             { min: 3, max: 254, args: "rrs*",   syntax: "SUMIFS(sum_range, range1, criteria1, ...)",  desc: "Multi-criteria sum" },
  "MOYENNE.SI":       { min: 2, max: 3,   args: "rsr",    syntax: "MOYENNE.SI(plage; critère; [moy_plage])",    desc: "Moyenne conditionnelle" },
  AVERAGEIF:          { min: 2, max: 3,   args: "rsr",    syntax: "AVERAGEIF(range, criteria, [avg_range])",    desc: "Conditional average" },
  "MOYENNE.SI.ENS":   { min: 3, max: 254, args: "rrs*",   syntax: "MOYENNE.SI.ENS(moy_plage; plage1; critère1; ...)", desc: "Moyenne multi-critères" },
  AVERAGEIFS:         { min: 3, max: 254, args: "rrs*",   syntax: "AVERAGEIFS(avg_range, range1, criteria1, ...)", desc: "Multi-criteria average" },

  // ── Recherche ──
  RECHERCHEV:         { min: 3, max: 4,   args: "rrnb",   syntax: "RECHERCHEV(valeur; table; col; [approx])",   desc: "Recherche verticale" },
  VLOOKUP:            { min: 3, max: 4,   args: "rrnb",   syntax: "VLOOKUP(value, table, col, [approx])",       desc: "Vertical lookup" },
  RECHERCHEH:         { min: 3, max: 4,   args: "rrnb",   syntax: "RECHERCHEH(valeur; table; ligne; [approx])", desc: "Recherche horizontale" },
  HLOOKUP:            { min: 3, max: 4,   args: "rrnb",   syntax: "HLOOKUP(value, table, row, [approx])",       desc: "Horizontal lookup" },
  RECHERCHEX:         { min: 3, max: 6,   args: "rrraan", syntax: "RECHERCHEX(cherché; plage_recherche; plage_résultat; [défaut]; [mode]; [recherche])", desc: "Recherche moderne (XLOOKUP)" },
  XLOOKUP:            { min: 3, max: 6,   args: "rrraan", syntax: "XLOOKUP(lookup, lookup_range, return_range, [default], [match], [search])", desc: "Modern lookup" },
  INDEX:              { min: 2, max: 3,   args: "rnn",    syntax: "INDEX(tableau; ligne; [colonne])",            desc: "Valeur à une position" },
  EQUIV:              { min: 2, max: 3,   args: "arn",    syntax: "EQUIV(valeur; plage; [type])",                desc: "Position d'une valeur" },

  // ── Texte ──
  GAUCHE:             { min: 1, max: 2,   args: "sn",     syntax: "GAUCHE(texte; [nb_car])",                    desc: "Premiers caractères" },
  LEFT:               { min: 1, max: 2,   args: "sn",     syntax: "LEFT(text, [num_chars])",                    desc: "First characters" },
  DROITE:             { min: 1, max: 2,   args: "sn",     syntax: "DROITE(texte; [nb_car])",                    desc: "Derniers caractères" },
  RIGHT:              { min: 1, max: 2,   args: "sn",     syntax: "RIGHT(text, [num_chars])",                   desc: "Last characters" },
  STXT:               { min: 3, max: 3,   args: "snn",    syntax: "STXT(texte; position; nb_car)",              desc: "Extrait du texte" },
  MID:                { min: 3, max: 3,   args: "snn",    syntax: "MID(text, start, num_chars)",                desc: "Extracts text" },
  NBCAR:              { min: 1, max: 1,   args: "s",      syntax: "NBCAR(texte)",                               desc: "Nombre de caractères" },
  LEN:                { min: 1, max: 1,   args: "s",      syntax: "LEN(text)",                                  desc: "Number of characters" },
  MAJUSCULE:          { min: 1, max: 1,   args: "s",      syntax: "MAJUSCULE(texte)",                           desc: "Convertit en majuscules" },
  UPPER:              { min: 1, max: 1,   args: "s",      syntax: "UPPER(text)",                                desc: "Converts to uppercase" },
  MINUSCULE:          { min: 1, max: 1,   args: "s",      syntax: "MINUSCULE(texte)",                           desc: "Convertit en minuscules" },
  LOWER:              { min: 1, max: 1,   args: "s",      syntax: "LOWER(text)",                                desc: "Converts to lowercase" },
  NOMPROPRE:          { min: 1, max: 1,   args: "s",      syntax: "NOMPROPRE(texte)",                           desc: "Première lettre en majuscule" },
  PROPER:             { min: 1, max: 1,   args: "s",      syntax: "PROPER(text)",                               desc: "Capitalizes first letter" },
  CONCATENER:         { min: 1, max: 255, args: "s*",     syntax: "CONCATENER(texte1; [texte2]; ...)",          desc: "Concatène du texte" },
  CONCAT:             { min: 1, max: 255, args: "s*",     syntax: "CONCAT(texte1; [texte2]; ...)",              desc: "Concatène du texte (version courte)" },
  CONCATENATE:        { min: 1, max: 255, args: "s*",     syntax: "CONCATENATE(text1, [text2], ...)",           desc: "Concatenates text" },
  TEXTE:              { min: 2, max: 2,   args: "ns",     syntax: "TEXTE(valeur; format)",                      desc: "Formate un nombre en texte" },
  TEXT:                { min: 2, max: 2,   args: "ns",     syntax: "TEXT(value, format_text)",                    desc: "Formats number as text" },
  SUBSTITUE:          { min: 3, max: 4,   args: "sssn",   syntax: "SUBSTITUE(texte; ancien; nouveau; [occurrence])", desc: "Remplace du texte" },
  SUBSTITUTE:         { min: 3, max: 4,   args: "sssn",   syntax: "SUBSTITUTE(text, old, new, [instance])",     desc: "Replaces text" },
  SUPPRESPACE:        { min: 1, max: 1,   args: "s",      syntax: "SUPPRESPACE(texte)",                         desc: "Supprime les espaces superflus" },
  TRIM:               { min: 1, max: 1,   args: "s",      syntax: "TRIM(text)",                                 desc: "Removes extra spaces" },

  // ── Date ──
  AUJOURDHUI:         { min: 0, max: 0,   args: "",       syntax: "AUJOURDHUI()",                               desc: "Date du jour" },
  TODAY:              { min: 0, max: 0,   args: "",       syntax: "TODAY()",                                    desc: "Today's date" },
  MAINTENANT:         { min: 0, max: 0,   args: "",       syntax: "MAINTENANT()",                               desc: "Date et heure actuelles" },
  NOW:                { min: 0, max: 0,   args: "",       syntax: "NOW()",                                      desc: "Current date and time" },
  ANNEE:              { min: 1, max: 1,   args: "n",      syntax: "ANNEE(date)",                                desc: "Extrait l'année" },
  YEAR:               { min: 1, max: 1,   args: "n",      syntax: "YEAR(date)",                                 desc: "Extracts year" },
  MOIS:               { min: 1, max: 1,   args: "n",      syntax: "MOIS(date)",                                 desc: "Extrait le mois" },
  MONTH:              { min: 1, max: 1,   args: "n",      syntax: "MONTH(date)",                                desc: "Extracts month" },
  JOUR:               { min: 1, max: 1,   args: "n",      syntax: "JOUR(date)",                                 desc: "Extrait le jour" },
  DAY:                { min: 1, max: 1,   args: "n",      syntax: "DAY(date)",                                  desc: "Extracts day" },
  DATE:               { min: 3, max: 3,   args: "nnn",    syntax: "DATE(année; mois; jour)",                    desc: "Crée une date" },
  JOURSEM:            { min: 1, max: 2,   args: "nn",     syntax: "JOURSEM(date; [type])",                      desc: "Jour de la semaine" },
  WEEKDAY:            { min: 1, max: 2,   args: "nn",     syntax: "WEEKDAY(date, [type])",                      desc: "Day of the week" },
  "FIN.MOIS":         { min: 2, max: 2,   args: "nn",     syntax: "FIN.MOIS(date_départ; mois)",                desc: "Dernier jour du mois" },
  EOMONTH:            { min: 2, max: 2,   args: "nn",     syntax: "EOMONTH(start_date, months)",                desc: "End of month" },

  // ── Stats ──
  RANG:               { min: 2, max: 3,   args: "nrn",    syntax: "RANG(nombre; réf; [ordre])",                 desc: "Rang d'une valeur" },
  RANK:               { min: 2, max: 3,   args: "nrn",    syntax: "RANK(number, ref, [order])",                 desc: "Rank of a value" },
  "GRANDE.VALEUR":    { min: 2, max: 2,   args: "rn",     syntax: "GRANDE.VALEUR(plage; k)",                    desc: "K-ième plus grande valeur" },
  LARGE:              { min: 2, max: 2,   args: "rn",     syntax: "LARGE(array, k)",                            desc: "K-th largest value" },
  "PETITE.VALEUR":    { min: 2, max: 2,   args: "rn",     syntax: "PETITE.VALEUR(plage; k)",                    desc: "K-ième plus petite valeur" },
  SMALL:              { min: 2, max: 2,   args: "rn",     syntax: "SMALL(array, k)",                            desc: "K-th smallest value" },
};

export const EXCEL_FUNCTIONS = Object.keys(FN_CATALOG);